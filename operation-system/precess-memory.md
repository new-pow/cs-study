# 프로세스 주소 공간

- 프로그램이 CPU에 실행되면 프로세스가 생성되며 메모리에 프로세스 주소 공간이 할당된다.
- 프로세스 주소 공간은 프로세스가 해당 코드에서 참조하는 논리 주소 집합이다. OS는 논리 주소를 실제 물리 주소에 매핑하는 추가 작업도 한다.

| 주소 유형 | 설명 |
| --- | --- |
| 물리적 주소 | 프로그램이 메인 메모리에 로드될 때 컴파일 후 로더는 물리적 주소에 대한 매핑을 생성합니다. |
| 상대 주소 | 무엇이든 컴파일할 때 컴파일러는 기호 주소를 상대 주소로 변환합니다. |
| 기호 주소 | 대부분 소스 코드에서 참조되는 주소가 있습니다. 구성 요소는 변수 이름, 상수 및 명령 레이블일 수 있습니다. |
- 구성
    - Code(text) 영역 : 프로그램을 실행시키는 실행 파일 내의 명령어들이 위치하는 공간
    - Data 영역 : 전역변수, static 변수들이 위치하는 공간
    - Heap 영역 : 동적할당을 위한 메모리 영역(malloc(), new 등)
    - Stack 영역 : 지역 변수, 파라미터(함수에 전달되는 인자)가 위치하는 공간

![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F020f61b7-69ed-4607-9af3-0cb5cfc7d93a%2FUntitled.png?id=d5ebdb37-ca4d-411c-8678-21e4ec1b4e85&table=block&spaceId=1feb7462-9c33-4bf1-b0bb-7973d34ffaf2&width=2000&userId=180a704c-6552-4796-9dd2-ab125439ed98&cache=v2)

## code (text)

- 우리가 작성한 **소스코드**가 들어 가는 부분. 즉, 실행할 프로그램의 코드가 저장되는 영역으로 **텍스트(code)영역** 이라고도 부른다.
- 코드영역은 실행 파일을 구성하는 명령어들이 올라가는 메모리 영역으로 **함수, 제어문, 상수** 등이 여기에 지정된다.
- 컴파일 타임에 결정되고 중간에 코드를 바꿀 수 없게 **Read-Only** 로 지정돼있다.

## data

- 프로그램의 전역 변수와 정적(static) 변수가 저장되는 영역. 즉, 프로그램이 구동되는 동안 항상 접근 가능한 변수가 저장되는 영역이다.
- 전역변수, static 값을 참조한 코드는 컴파일 하고 나면 Data 영역의 주소값을 가르키도록 바뀐다.
- 데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸한다.
- 초기화되지 않은 전역변수는 BSS영역으로 저장된다.

<aside>
❗ 나누는 이유

초기화된 변수는 초기값을 저장해야해서 ROM에 저장된다. 초기화하지 않은 데이터까지 ROM에 저장하면 필요한 ROM의 크기가 커져 비용이 많이 들게 된다. 따라서, 초기화되지 않은 데이터는 RAM에 저장하도록 한다.

</aside>

- 실행 중도에 전역변수가 변경 될 수도 있으니 이 영역은 **Read-Write**로 지정돼있다.

## stack

- 함수의 호출과 관계되는 **지역 변수와 매개변수가 저장되는 영역**이다.
- `Stack`은 함수의 호출과 함께 할당되며, **함수의 호출이 완료되면 소멸**한다.
- 원시타입의 데이터가 값과 함께 할당된다.
- Heap 영역에 생성된 `Object` 타입의 데이터 참조값이 할당된다.
- 메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다.
- **컴파일 타임에 크기가 결정되기 때문에 무한히 할당 할 수 없다.** 재귀함수가 너무 깊게 호출되거나 함수가 지역변수를 너무 많이 가지고 있어 stack 영역을 초과하면 **`stack overflow` 에러**가 발생한다.
- 이 영역은 **Read-Write**로 지정돼있다.

## heap

- **런타임에 크기가 결정되는 메모리 영역**이다.
- 사용자에 의해 메모리 **공간이 동적으로 할당되고 해제**된다.
- 참조형의 데이터의 값이 저장된다.
    - ~~예를 들어 클래스, 클로저가 이 부분에 해당 된다.~~
- Heap은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당된다.
- HEAP과 STACK영역은 사실 같은 공간을 공유한다. HEAP이 메모리 위쪽 주소부터 할당되면 STACK은 아래쪽부터 할당되는 식이다. 그래서 각 영역이 상대 공간을 침범하는 일이 발생할 수 있는데 이를 각각 `HEAP OVERFLOW`, `STACK OVERFLOW`라고 칭한다.

![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F5a96f5dd-4c2f-42eb-b87d-cb92acc74dff%2FUntitled.png?id=56a335c1-b759-40c4-8bb6-a9f7b843cf75&table=block&spaceId=1feb7462-9c33-4bf1-b0bb-7973d34ffaf2&width=2000&userId=180a704c-6552-4796-9dd2-ab125439ed98&cache=v2)

<aside>
❗ 커널은 힙메모리가 없다!

'[커널(kernel)](https://www.redhat.com/ko/topics/linux/what-is-the-linux-kernel) == 운영체제'가 아니라, 커널은 운영체제의 주요 구성 요소.
리눅스로 예를 들자면, 커널은 메모리 관리, 프로세스 관리, 하드웨어와 프로세스 사이에서 인터프리터 역할을 수행하거나 시스템의 호출이나 보안등의 기능을 수행한다.
즉, 리눅스에서(다른 OS는 다를 수 있음) 커널은 하나의 프로세스가 아니라 **컴퓨터 하드웨어와 프로세스를 잇는 인터페이스**로 보아야 한다.

**커널은 힙메모리를 사용하지 않는다. 커널은 운영체제(리눅스)에서 동적메모리 할당을 위해 필요한 기능들을 커널이 제공하는데, 운영체제는 커널에서 제공하는 기능을 사용해서 메모리 풀(memory pool)을 관리.**

</aside>